# 다양한 렌더링 기법들

React와 Next.js를 사용하다 보면 **CSR, SSR, SSG, ISR**이라는 용어를 자주 마주치게 됩니다. 이들은 모두 "언제, 어디서 HTML을 만들어서 사용자에게 보여줄 것인가?"에 대한 다른 답변입니다.

이 글에서는 각 렌더링 방식이 왜 등장했는지, 어떻게 동작하는지, 그리고 언제 사용하면 좋은지를 **문제를 해결해 나가는 진화 과정**처럼 설명해보겠습니다.

---

## 1. CSR (Client-Side Rendering)

### [1] 정의

**CSR은 브라우저에서 JavaScript를 실행해 HTML을 동적으로 생성하는 렌더링 방식**입니다. 서버는 빈 HTML 껍데기와 JavaScript 번들만 보내주고, 실제 화면 구성은 클라이언트(브라우저)에서 담당합니다.

### [2] 등장 배경

전통적인 웹 개발 방식(Multi-Page Application, MPA)은 매 페이지 이동마다 서버에서 완성된 HTML을 받아와야 했습니다. 이는 사용자 경험 측면에서 매끄럽지 못했습니다.

**React 같은 SPA(Single Page Application) 프레임워크가 등장**하면서, 한 번 페이지를 로드한 후 JavaScript로 페이지 전환을 처리하는 방식이 대세가 되었습니다. 이때 사용된 방식이 바로 CSR입니다.

### [3] 렌더링 동작 흐름

**최초 접속 (Initial Load):**

1. 사용자가 URL에 접속
2. 서버는 `index.html`을 전송 (거의 비어있음, `<div id="root"></div>` 정도만)
3. 브라우저가 HTML을 파싱하고, `<script>` 태그를 발견하면 JavaScript 파일을 다운로드
4. JavaScript가 실행되면서 React가 마운트되고, API 호출을 통해 데이터를 가져옴
5. 데이터를 받아온 후 컴포넌트가 렌더링되어 화면에 표시
6. **Hydration**: React가 이벤트 리스너를 연결하고 상호작용 가능한 상태가 됨

**이후 페이지 이동 (Client-side Navigation):**

1. 사용자가 링크 클릭 또는 프로그래밍 방식으로 라우팅
2. JavaScript가 URL을 변경하고 (History API 사용)
3. 해당 경로의 컴포넌트를 렌더링
4. 필요하면 API 호출 후 화면 업데이트
5. **서버 요청 없이** 즉시 화면 전환 완료

### [4] 장점

- **빠른 페이지 전환**: 초기 로드 후에는 서버 요청 없이 즉시 화면 전환이 가능합니다. 마치 네이티브 앱처럼 부드러운 UX를 제공할 수 있습니다.
- **서버 부하 감소**: 서버는 정적 파일만 제공하면 되므로, 트래픽이 많아도 서버 리소스 부담이 적습니다.
- **개발 편의성**: React Router 같은 라이브러리로 클라이언트 라우팅을 쉽게 구현할 수 있고, 상태 관리도 클라이언트에서 일관되게 처리할 수 있습니다.
- **캐싱 효율**: JavaScript 번들을 CDN에 캐싱해두면 전 세계 어디서나 빠르게 제공할 수 있습니다.

### [5] 한계점 / 단점

- **느린 초기 로딩 (TTI 지연)**: JavaScript 번들을 다운로드하고 실행해야 화면이 보이기 시작합니다. 특히 번들 크기가 크거나 네트워크가 느리면 **TTI(Time to Interactive)**가 길어져 사용자가 오래 기다려야 합니다.
- **SEO 문제**: 검색 엔진 크롤러가 JavaScript를 실행하지 못하거나, 실행하더라도 시간이 걸려서 **빈 페이지나 불완전한 콘텐츠**를 인덱싱할 수 있습니다.
- **빈 화면 문제**: 초기 로드 시 사용자에게는 빈 화면이나 로딩 스피너만 보이게 됩니다. 이는 첫인상에 좋지 않습니다.
- **메타데이터 관리 어려움**: 각 페이지마다 다른 `<title>`, `<meta>` 태그를 동적으로 변경해야 하는데, SNS 공유 시 올바른 미리보기가 나오지 않을 수 있습니다.

### [6] 언제 적합한가

- **로그인 이후의 대시보드, 관리자 페이지**: 사용자별로 다른 데이터를 보여주는 페이지로, SEO가 중요하지 않고 인증된 사용자만 접근합니다.
- **실시간 데이터가 중요한 앱**: 주식 차트, 채팅 앱처럼 데이터가 자주 변하고 상호작용이 많은 경우
- **SPA가 필수인 경우**: 복잡한 상태 관리와 라우팅이 필요한 웹 애플리케이션

---

## 2. SSR (Server-Side Rendering)

### [1] 정의

**SSR은 서버에서 React 컴포넌트를 렌더링해 완성된 HTML을 브라우저에 전송하는 방식**입니다. 사용자는 이미 콘텐츠가 채워진 HTML을 받아서 바로 볼 수 있습니다.

### [2] 등장 배경

CSR의 가장 큰 문제는 **초기 로딩이 느리고 SEO가 안 된다**는 점이었습니다. 특히 블로그, 뉴스 사이트처럼 검색 엔진 노출이 중요한 서비스에서는 치명적이었죠.

**"그럼 서버에서 미리 렌더링해서 보내주면 되지 않을까?"**라는 아이디어에서 SSR이 등장했습니다. Next.js 같은 프레임워크가 이를 쉽게 구현할 수 있게 해주었습니다.

### [3] 렌더링 동작 흐름

**최초 접속 (Initial Load):**

1. 사용자가 URL에 접속
2. 서버가 요청을 받고, 해당 경로의 React 컴포넌트를 실행
3. 서버에서 필요한 데이터를 가져옴 (API 호출, DB 조회 등)
4. 서버에서 React를 실행해 **완성된 HTML 문자열을 생성**
5. 이 HTML을 응답으로 전송 (JavaScript 번들도 함께)
6. 브라우저가 HTML을 받아 즉시 화면에 표시 (이미 콘텐츠가 있음!)
7. JavaScript가 다운로드되고 실행되면서 **Hydration** 진행: React가 기존 HTML에 이벤트 리스너를 연결
8. 이제 상호작용 가능한 상태가 됨

**이후 페이지 이동 (Client-side Navigation):**

Next.js의 경우, 기본적으로는 **클라이언트 사이드 네비게이션**을 사용합니다:

1. 사용자가 `<Link>` 컴포넌트로 링크 클릭
2. Next.js가 JavaScript로 페이지를 미리 로드 (prefetch)
3. 필요하면 서버에 요청해 JSON 데이터를 받아옴
4. 클라이언트에서 새 페이지를 렌더링
5. 서버 요청 없이 부드럽게 전환

하지만 `getServerSideProps`를 사용하면 매번 서버에서 렌더링합니다.

### [4] 장점

- **빠른 초기 로딩**: HTML에 콘텐츠가 이미 들어있어서 **FCP(First Contentful Paint)**가 빠릅니다. 사용자는 로딩 스피너 대신 실제 콘텐츠를 바로 볼 수 있습니다.
- **SEO 최적화**: 검색 엔진이 완성된 HTML을 받아가므로, **콘텐츠가 제대로 인덱싱**됩니다.
- **메타데이터 관리**: 서버에서 각 페이지마다 적절한 `<title>`, `<meta>` 태그를 넣어줄 수 있어서, SNS 공유 시 올바른 미리보기가 나옵니다.
- **사용자별 맞춤 콘텐츠**: 서버에서 렌더링하므로, 요청 시점의 사용자 정보를 바탕으로 **개인화된 콘텐츠**를 제공할 수 있습니다.

### [5] 한계점 / 단점

- **서버 부하**: 매 요청마다 서버에서 렌더링을 수행해야 하므로, **트래픽이 많을수록 서버 리소스가 많이 필요**합니다.
- **느린 TTI**: HTML은 빨리 보이지만, JavaScript가 다운로드되고 Hydration이 완료될 때까지는 **상호작용이 불가능**합니다. 특히 Hydration이 오래 걸리면 "버튼을 눌렀는데 반응이 없다"는 경험을 줄 수 있습니다.
- **복잡한 상태 관리**: 서버와 클라이언트 모두에서 코드가 실행되므로, `window`, `document` 같은 브라우저 전용 API 사용 시 주의가 필요합니다.
- **TTFB 지연**: 서버에서 렌더링하는 시간이 포함되므로, **TTFB(Time to First Byte)**가 CSR보다 길 수 있습니다.

### [6] 언제 적합한가

- **블로그, 뉴스 사이트**: SEO가 중요하고, 콘텐츠가 자주 업데이트되는 페이지
- **사용자별 맞춤 페이지**: 로그인한 사용자에게 개인화된 대시보드를 보여주는 경우
- **동적 메타데이터가 중요한 페이지**: SNS 공유 시 각 게시글마다 다른 미리보기를 보여줘야 하는 경우
- **실시간 데이터가 필요한 페이지**: 주식 가격, 경매 사이트처럼 매 요청마다 최신 데이터를 보여줘야 하는 경우

---

## 3. SSG (Static Site Generation)

### [1] 정의

**SSG는 빌드 타임에 모든 페이지를 미리 렌더링해 정적 HTML 파일로 만들어두는 방식**입니다. 사용자가 요청하면 이미 만들어진 HTML을 그대로 전송합니다.

### [2] 등장 배경

SSR은 SEO와 초기 로딩 속도 문제를 해결했지만, **매 요청마다 서버에서 렌더링**해야 하는 부담이 있었습니다. 트래픽이 폭증하면 서버가 감당하기 어려워지죠.

**"변하지 않는 페이지는 미리 만들어두면 되지 않을까?"**라는 아이디어에서 SSG가 등장했습니다. 블로그 포스트, 제품 소개 페이지처럼 콘텐츠가 자주 바뀌지 않는 페이지에 특히 적합합니다.

### [3] 렌더링 동작 흐름

**빌드 타임 (Build Time):**

1. `next build` 명령어 실행
2. Next.js가 `getStaticProps`가 있는 페이지들을 찾음
3. 각 페이지마다 필요한 데이터를 가져옴 (API, 파일 시스템, DB 등)
4. 서버에서 React를 실행해 **완성된 HTML 파일을 생성**
5. 생성된 HTML 파일들을 `.next` 폴더에 저장
6. JavaScript 번들도 함께 생성

**최초 접속 (Initial Load):**

1. 사용자가 URL에 접속
2. 서버(또는 CDN)가 **이미 만들어진 HTML 파일**을 전송
3. 브라우저가 HTML을 받아 즉시 화면에 표시 (콘텐츠가 이미 있음!)
4. JavaScript가 다운로드되고 실행되면서 **Hydration** 진행
5. 상호작용 가능한 상태가 됨

**이후 페이지 이동 (Client-side Navigation):**

1. 사용자가 링크 클릭
2. Next.js가 미리 생성된 HTML과 JSON 데이터를 가져옴
3. 클라이언트에서 새 페이지를 렌더링
4. **서버 렌더링 없이** 즉시 화면 전환

### [4] 장점

- **매우 빠른 로딩 속도**: HTML이 이미 만들어져 있어서 **TTFB가 거의 0에 가깝습니다**. CDN에 배포하면 전 세계 어디서나 빠르게 제공할 수 있습니다.
- **서버 부하 없음**: 정적 파일만 제공하면 되므로, **트래픽이 아무리 많아도 서버 부담이 거의 없습니다**. 서버 비용도 절감됩니다.
- **SEO 최적화**: 완성된 HTML이므로 검색 엔진이 완벽하게 인덱싱할 수 있습니다.
- **안정성**: 서버에서 런타임 에러가 발생할 걱정이 없습니다. 빌드 타임에 문제를 발견할 수 있습니다.
- **캐싱 효율**: 정적 파일은 CDN과 브라우저에서 오래 캐싱할 수 있어서, 반복 방문 시 매우 빠릅니다.

### [5] 한계점 / 단점

- **동적 콘텐츠 불가**: 빌드 타임에 모든 페이지를 만들기 때문에, **사용자별로 다른 콘텐츠를 보여줄 수 없습니다**. 예를 들어 "내가 작성한 글" 같은 페이지는 SSG로 만들 수 없습니다.
- **빌드 시간 증가**: 페이지가 많아질수록 빌드 시간이 길어집니다. 수만 개의 페이지가 있으면 빌드에 몇 시간이 걸릴 수도 있습니다.
- **콘텐츠 업데이트 지연**: 새 글이 작성되어도 **다시 빌드하고 배포해야** 반영됩니다. 실시간성이 중요한 서비스에는 부적합합니다.
- **서버 사이드 로직 제한**: `getServerSideProps` 같은 서버 사이드 함수를 사용할 수 없습니다.

### [6] 언제 적합한가

- **블로그, 문서 사이트**: 콘텐츠가 자주 바뀌지 않고, SEO가 중요한 페이지
- **마케팅 랜딩 페이지**: 제품 소개, 이벤트 페이지처럼 정적인 콘텐츠
- **포트폴리오 사이트**: 개인 포트폴리오, 회사 소개 페이지
- **이벤트 페이지**: 기간이 정해진 이벤트 페이지 (빌드 시점에 모든 페이지 생성)

---

## 4. ISR (Incremental Static Regeneration)

### [1] 정의

**ISR은 SSG의 장점을 유지하면서, 특정 주기마다 또는 요청 시점에 페이지를 재생성하는 방식**입니다. 빌드 타임에 모든 페이지를 만들 필요 없이, 필요할 때만 생성하고 업데이트할 수 있습니다.

### [2] 등장 배경

SSG는 빠르고 안정적이지만, **"모든 페이지를 빌드 타임에 만들어야 한다"**는 제약이 있었습니다. 블로그에 글이 10만 개 있다면? 빌드에 며칠이 걸릴 수도 있습니다.

또한 **"콘텐츠가 바뀌면 다시 빌드해야 한다"**는 문제도 있었습니다. 새 글이 올라올 때마다 전체 사이트를 다시 빌드하는 건 비효율적이죠.

**"필요한 페이지만 생성하고, 오래된 페이지는 주기적으로 업데이트하면 되지 않을까?"**라는 아이디어에서 ISR이 등장했습니다.

### [3] 렌더링 동작 흐름

**빌드 타임 (Build Time):**

1. `next build` 명령어 실행
2. Next.js가 `getStaticProps`에 `revalidate` 옵션이 있는 페이지를 찾음
3. **일부 페이지만 미리 생성** (예: 인기 페이지 100개만)
4. 나머지 페이지는 **요청 시점에 생성** (On-demand)

**최초 접속 (Initial Load):**

**케이스 1: 이미 생성된 페이지인 경우**

1. 사용자가 URL에 접속
2. 서버가 이미 만들어진 HTML 파일을 전송
3. 브라우저가 즉시 화면에 표시
4. Hydration 진행

**케이스 2: 아직 생성되지 않은 페이지인 경우 (On-demand Generation)**

1. 사용자가 URL에 접속
2. 서버가 해당 페이지가 없다는 것을 발견
3. 서버에서 **즉시 페이지를 생성** (첫 요청자는 조금 기다려야 함)
4. 생성된 HTML을 전송하고, `.next` 폴더에 저장
5. 다음 요청부터는 이미 생성된 HTML을 사용

**재생성 (Revalidation):**

**케이스 1: 시간 기반 재생성 (`revalidate: 60`)**

1. 페이지가 생성된 후 60초가 지남
2. 다음 요청이 들어오면, **백그라운드에서 페이지를 재생성**
3. 기존 HTML은 그대로 제공하고, 재생성이 완료되면 교체
4. 사용자는 항상 빠른 응답을 받음

**케이스 2: On-demand 재생성 (`revalidate` 없이 API 라우트 사용)**

1. 콘텐츠가 업데이트됨 (예: 새 블로그 글이 작성됨)
2. API 라우트를 호출해 특정 페이지 재생성 요청
3. 서버가 해당 페이지를 재생성
4. 다음 요청부터는 새 콘텐츠가 반영됨

### [4] 장점

- **빌드 시간 단축**: 모든 페이지를 미리 만들 필요가 없어서, **빌드 시간이 크게 줄어듭니다**. 수만 개의 페이지가 있어도 빌드는 빠르게 끝납니다.
- **동적 콘텐츠 업데이트**: `revalidate` 옵션으로 주기적으로 페이지를 업데이트할 수 있어서, **SSG보다는 유연하게 콘텐츠를 관리**할 수 있습니다.
- **SSG의 모든 장점**: 빠른 로딩 속도, 서버 부하 없음, SEO 최적화 등 SSG의 장점을 그대로 가집니다.
- **확장성**: 페이지가 수만 개, 수십만 개여도 문제없이 운영할 수 있습니다.
- **비용 효율**: 정적 파일 제공이므로 서버 비용이 저렴합니다.

### [5] 한계점 / 단점

- **첫 요청 지연**: 아직 생성되지 않은 페이지에 첫 요청이 들어오면, **서버에서 생성하는 시간이 걸려서 응답이 느릴 수 있습니다**. 이를 "Cold Start" 문제라고 합니다.
- **콘텐츠 업데이트 지연**: `revalidate` 시간이 지나기 전까지는 **오래된 콘텐츠가 보일 수 있습니다**. 예를 들어 `revalidate: 3600` (1시간)이면, 최대 1시간 동안 이전 콘텐츠가 노출될 수 있습니다.
- **복잡도 증가**: 언제 페이지를 생성하고, 언제 재생성할지 전략을 세워야 합니다.
- **서버 리소스 필요**: On-demand 생성 시 서버에서 렌더링을 수행해야 하므로, 트래픽이 몰리면 서버 부하가 발생할 수 있습니다.

### [6] 언제 적합한가

- **대규모 블로그, 쇼핑몰**: 페이지가 수만 개 이상인 경우
- **콘텐츠가 가끔 업데이트되는 사이트**: 뉴스 사이트, 제품 카탈로그처럼 주기적으로 업데이트되지만 실시간은 아닌 경우
- **E-commerce**: 제품 페이지가 많고, 가격이나 재고가 가끔 바뀌는 경우
- **문서 사이트**: 문서가 많고, 가끔 업데이트되는 경우 (예: Next.js 공식 문서)

---

## 비교 요약

### 렌더링 방식 비교 표

| 렌더링 방식 | 렌더링 시점                  | 초기 로딩 속도                 | SEO  | 서버 부하                 | 동적 콘텐츠             |
| ----------- | ---------------------------- | ------------------------------ | ---- | ------------------------- | ----------------------- |
| **CSR**     | 브라우저 (클라이언트)        | 느림 (JS 번들 다운로드 필요)   | 나쁨 | 낮음 (정적 파일만 제공)   | 가능                    |
| **SSR**     | 서버 (요청 시마다)           | 빠름 (HTML에 콘텐츠 포함)      | 좋음 | 높음 (매 요청마다 렌더링) | 가능                    |
| **SSG**     | 빌드 타임                    | 매우 빠름 (이미 생성된 HTML)   | 좋음 | 없음 (정적 파일만 제공)   | 불가능                  |
| **ISR**     | 빌드 타임 + 요청 시 (점진적) | 매우 빠름 (대부분 이미 생성됨) | 좋음 | 낮음 (필요 시에만 생성)   | 제한적 (재생성 주기 내) |

### 왜 Next.js는 CSR/SSR/SSG/ISR을 함께 제공하는가?

**각 렌더링 방식은 서로 다른 문제를 해결하기 위해 등장했습니다.**

- **CSR**: 빠른 페이지 전환과 서버 부하 감소를 위해
- **SSR**: SEO와 초기 로딩 속도 문제를 해결하기 위해
- **SSG**: 서버 부하 없이 빠른 속도와 SEO를 동시에 얻기 위해
- **ISR**: 대규모 사이트에서도 SSG의 장점을 활용하기 위해

**실제 서비스에서는 페이지마다 요구사항이 다릅니다.**

- 마케팅 랜딩 페이지 → **SSG** (변하지 않는 정적 콘텐츠)
- 블로그 포스트 → **ISR** (가끔 업데이트되는 콘텐츠)
- 사용자 대시보드 → **SSR** 또는 **CSR** (사용자별 맞춤 콘텐츠)
- 실시간 채팅 → **CSR** (실시간 상호작용)

**Next.js는 이런 다양한 요구사항을 하나의 프레임워크에서 해결할 수 있게 해줍니다.**

- 같은 프로젝트에서 페이지마다 다른 렌더링 방식을 선택할 수 있습니다.
- `getStaticProps` → SSG/ISR
- `getServerSideProps` → SSR
- 둘 다 없으면 → CSR

이렇게 **"하이브리드 렌더링"**을 통해 각 페이지의 특성에 맞는 최적의 방식을 선택할 수 있는 것이 Next.js의 강점입니다.

---

## 마무리

렌더링 전략은 **"완벽한 하나의 방식"**이 아니라, **"상황에 맞는 최적의 선택"**입니다. 각 방식의 장단점을 이해하고, 프로젝트의 요구사항에 맞게 선택하는 것이 중요합니다.

면접에서 물어본다면 이렇게 답변할 수 있습니다:

> "CSR은 빠른 페이지 전환을 위해 등장했지만 SEO와 초기 로딩 문제가 있었고, SSR이 이를 해결했지만 서버 부하 문제가 있었습니다. SSG는 서버 부하 없이 빠른 속도를 제공하지만 모든 페이지를 빌드해야 하는 제약이 있었고, ISR은 이를 개선해 필요한 페이지만 생성하고 주기적으로 업데이트하는 방식입니다. Next.js는 페이지마다 다른 렌더링 방식을 선택할 수 있어서, 각 페이지의 특성에 맞는 최적의 방식을 적용할 수 있습니다."

이제 각 렌더링 방식의 특징을 이해했으니, 프로젝트에 적용해보시기 바랍니다! 🚀
